use anyhow::Result;
use embedded_svc::{wifi::{AccessPointConfiguration, ClientConfiguration}, mqtt::client::QoS};
use led_controller::{LedController, LedState};
use log::info;
use mqtt::{color_topic, process_message};
use smart_leds_trait::RGB;
use utils::{get_default_nvs, NVS_PASS, NVS_SSID, swap_netif};
use wifi::{get_wifi, set_wifi};
use core::str;

use esp_idf_svc::{
    eventloop::{EspSystemEventLoop, EspEventLoop, System},
    hal::{prelude::*, modem::Modem, gpio::{PinDriver, Pull}},
    wifi::{EspWifi, BlockingWifi}, 
    sys::esp_random, 
    nvs::{EspDefaultNvsPartition, EspDefaultNvs}, 
    netif::{EspNetif, NetifConfiguration}, 
    mqtt::client::{EspMqttClient, MqttClientConfiguration, Event::Received},
    
};
use std::{
    thread::{sleep, spawn},
    time::Duration, error::Error, process,
};


mod http_server;
mod led_controller;
mod utils;
mod wifi;
mod mqtt;

const MAIN_POLL_RATE: u64 = 10;
const RESET_HOLD_TIME: u64 = 3000;

const UUID: &str = "d3400e66-5811-48c4-bafb-043ad14810a5";

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    device_name: &'static str,
    #[default("")]
    partner_name: &'static str,
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str
}

fn get_network_config() -> Option<(String, String)> {
    let nvs = get_default_nvs().lock().unwrap();

    let mut ssid_buf: [u8; 32] = [0_u8; 32];
    let mut pass_buf: [u8; 32] = [0_u8; 32];

    let ssid: Option<&str> = nvs.get_str(NVS_SSID, &mut ssid_buf).unwrap();
    let password: Option<&str> = nvs.get_str(NVS_PASS, &mut pass_buf).unwrap();
    
    if ssid.is_none() || password.is_none() {
        None
    } else {
        Some((ssid.unwrap().to_string(), password.unwrap().to_string()))
    }
}

fn reset_network_config() {
    let mut nvs = get_default_nvs().lock().unwrap();
    nvs.remove(NVS_SSID).expect("Failed to remove SSID");
    nvs.remove(NVS_PASS).expect("Failed to remove Password");

    process::exit(1);
}

fn start_ap(sysloop: EspEventLoop<System>, device_name: &str) -> Result<(), Box<dyn Error>> {
    let mut wifi = get_wifi().lock().unwrap();

    swap_netif(&mut wifi, device_name);

    // Enable the AP
    wifi.set_configuration(&embedded_svc::wifi::Configuration::Mixed(ClientConfiguration::default(), AccessPointConfiguration {
        ssid: device_name.into(),
        ..Default::default()
    }))?;

    wifi.start()?;
    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;
    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    LedController::set(LedState::Connecting);
    spawn(|| {
        loop {
            let lock = LedController::get_instance()
                .try_lock();

            if lock.is_err() {
                sleep(Duration::from_millis(10));
            } else {
                let mut led_controller = lock
                    .unwrap();
                led_controller.tick();
            }
            sleep(Duration::from_millis(10));

        }
    });

    
    let network_config = get_network_config();
    
    let is_setup = network_config.is_some();

    let connected = setup_wifi(peripherals.modem, sysloop, is_setup, network_config)?;

    let server =http_server::init();

    if connected {
        let broker_url = if CONFIG.mqtt_user != "" {
            format!(
                "mqtt://{}:{}@{}",
                CONFIG.mqtt_user, CONFIG.mqtt_pass, CONFIG.mqtt_host
            )
        } else {
            format!("mqtt://{}", CONFIG.mqtt_host)
        };
    
        let mqtt_config = MqttClientConfiguration::default();
    
    
        let mut mqtt = EspMqttClient::new(&broker_url, &mqtt_config, move |ev| match ev {
            Ok(Received(msg)) => process_message(msg),
            _ => {}
        }).unwrap();
    
        mqtt.subscribe(color_topic(UUID).as_str(), QoS::AtLeastOnce).unwrap();
        
        LedController::set_mqtt(mqtt);
    }

    let mut reset = PinDriver::input(peripherals.pins.gpio25).unwrap();
    let mut reset_timer = 0;
    reset.set_pull(Pull::Down)?;

    // Prevent program from exiting
    loop {
        if is_setup {
            if reset.is_high() {
                reset_timer = reset_timer + MAIN_POLL_RATE;
                info!("Reset Timer: {reset_timer}");
            } else {
                reset_timer = 0;
            }
    
            if reset_timer >= RESET_HOLD_TIME {
                for _ in 0..3 {
                    LedController::set(LedState::Color(RGB::new(128, 0, 0)));
                    sleep(Duration::from_millis(300));
                    LedController::set(LedState::Color(RGB::new(0, 0, 0)));
                    sleep(Duration::from_millis(300));
                }
                sleep(Duration::from_millis(700));

                reset_network_config();
            }
        }

        sleep(Duration::from_millis(MAIN_POLL_RATE));
    }
}

fn setup_wifi(modem: Modem, sysloop: esp_idf_svc::eventloop::EspEventLoop<esp_idf_svc::eventloop::System>, is_setup: bool, network_config: Option<(String, String)>) -> Result<bool, Box<dyn Error>> {
    set_wifi(modem, sysloop.clone());

    let mut connected = false;
    if !is_setup {
        start_ap(sysloop.clone(), CONFIG.device_name)?;
        info!("Awaiting Setup");
        connected = false;
        LedController::set(LedState::Setup);    
    } else {
        let (ssid, password) = network_config.unwrap();

        info!("Using Credientials: {ssid}, {password}");

        connected = wifi::connect(ssid.trim_matches(char::from(0)), password.trim_matches(char::from(0)), true)?;

        info!("Connected");
        if connected {
            LedController::set(LedState::Color(RGB::new(255,255,255)));
        } else {
            LedController::set(LedState::Setup);    
        }
    }
    
    Ok(connected)
}
